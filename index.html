<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vigilantor - Command Center</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <style>
        :root {
            --bg-color: #0d1117;
            --panel-bg: #161b22;
            --border-color: #30363d;
            --fg-color: #c9d1d9;
            --fg-color-muted: #8b949e;
            --accent-color: #2ea043;
            --accent-hover: #3ddc55;
            --error-color: #f85149;
            --stop-color: #da3633;
            --stop-hover: #f85149;
            --secondary-color: #21262d;
            --secondary-hover: #30363d;
            --font-main: 'Roboto', sans-serif;
            --font-mono: 'Fira Code', monospace;
            --shadow-color: rgba(0, 0, 0, 0.4);
        }
        * { box-sizing: border-box; }
        body {
            background-color: var(--bg-color);
            color: var(--fg-color);
            font-family: var(--font-main);
            margin: 0;
            padding: 2rem;
        }
        .container {
            max-width: 1400px;
            margin: auto;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 2rem;
            height: calc(100vh - 4rem);
        }
        .sidebar, .main-content {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 24px var(--shadow-color);
        }
        .sidebar-header {
            flex-shrink: 0;
        }
        .history-container {
            flex-grow: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        #history-list {
            overflow-y: auto;
            flex-grow: 1;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .creator-credit {
            flex-shrink: 0;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-family: var(--font-mono);
            color: var(--fg-color-muted);
            font-size: 0.8rem;
        }
        .main-content { padding: 0; }
        .main-content-body { padding: 1.5rem; flex-grow: 1; overflow: hidden; display: flex; flex-direction: column; position: relative; }
        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 2rem;
        }
        .logo-container svg {
            width: 40px;
            height: 40px;
        }
        h1 {
            font-family: var(--font-mono);
            color: var(--fg-color);
            text-align: center;
            font-size: 1.8rem;
            letter-spacing: 2px;
            margin: 0;
        }
        h2 {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--fg-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.75rem;
            margin-top: 2rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        label { display: block; margin: 1rem 0 0.5rem; font-weight: bold; font-size: 0.9rem; color: var(--fg-color-muted); }
        select, input {
            width: 100%;
            padding: 0.85rem;
            background-color: var(--bg-color);
            color: var(--fg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-hover);
            box-shadow: 0 0 0 3px rgba(46, 160, 67, 0.3);
        }
        .button-group { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1.5rem; }
        button {
            width: 100%;
            padding: 0.8rem;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-image 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }
        #start-scan-btn {
            background-image: linear-gradient(to right, #3ddc55, #2ea043);
            color: #ffffff;
            grid-column: 1 / -1;
        }
        #stop-scan-btn {
            background-image: linear-gradient(to right, #f85149, #da3633);
            color: #ffffff;
        }
        #clear-btn, #generate-pdf-btn {
            background-image: linear-gradient(to right, #30363d, #21262d);
            color: var(--fg-color);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .tab-nav { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 0; padding: 0 1.5rem; flex-shrink: 0; align-items: center; }
        .tab-link { padding: 0.75rem 1.25rem; cursor: pointer; border-bottom: 3px solid transparent; margin-bottom: -1px; color: var(--fg-color-muted); transition: color 0.2s ease; }
        .tab-link:hover { color: var(--fg-color); }
        .tab-link.active { color: var(--accent-hover); border-bottom-color: var(--accent-hover); }
        #generate-pdf-btn { margin-left: auto; width: auto; padding: 0.5rem 1rem; font-size: 0.9rem; }
        .tab-content { display: none; flex-grow: 1; overflow: hidden; }
        .tab-content.active {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        #scan-output { white-space: pre-wrap; word-wrap: break-word; font-family: var(--font-mono); font-size: 0.9rem; background-color: #010409; padding: 1rem; border-radius: 6px; overflow-y: auto; flex-grow: 1; }
        #report-content { font-family: var(--font-main); background-color: #010409; padding: 1.5rem; border-radius: 6px; overflow-y: auto; flex-grow: 1; line-height: 1.6; }
        #report-content h3 { color: var(--accent-color); border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; margin-top: 1.5rem; }
        #report-content h4 { color: var(--fg-color); margin-top: 1.5rem; margin-bottom: 0.5rem; border-left: 3px solid var(--accent-hover); padding-left: 0.75rem; }
        #report-content table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        #report-content th, #report-content td { border: 1px solid var(--border-color); padding: 0.75rem; text-align: left; font-size: 0.9rem; }
        #report-content th { background-color: var(--secondary-hover); font-weight: bold; }
        #report-content p { margin: 0.5rem 0; }
        #report-content code { background-color: var(--secondary-color); padding: 0.2rem 0.4rem; border-radius: 4px; font-family: var(--font-mono); }
        #report-content .executive-summary { background-color: var(--secondary-color); padding: 1rem; border-radius: 6px; border-left: 5px solid var(--accent-color); }
        #topology-graph { height: 100%; width: 100%; background-color: #010409; border-radius: 6px; border: 1px solid var(--border-color); }
        #history-list li { padding: 0.75rem; border-radius: 4px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        #history-list li:hover { background-color: var(--secondary-color); }
        #graph-tooltip {
            position: absolute;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 6px;
            pointer-events: none;
            display: none;
            font-size: 0.9rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo-container">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" color="var(--accent-color)"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"></path></svg>
                    <h1>VIGILANTOR</h1>
                </div>
                <h2>Nuevo Escaneo</h2>
                <form id="scan-form">
                    <label for="tool-select">Herramienta</label>
                    <select id="tool-select" required></select>
                    <div id="tool-params"></div>
                    <div class="button-group">
                        <button id="start-scan-btn" type="submit"><span>Ejecutar</span></button>
                        <button id="stop-scan-btn" type="button" style="display: none;">Detener</button>
                        <button id="clear-btn" type="button" style="display: none;">Limpiar</button>
                    </div>
                </form>
            </div>
            <div class="history-container">
                <h2>Historial</h2>
                <ul id="history-list"></ul>
            </div>
            <div class="creator-credit"><p>Created by LHPSecure</p></div>
        </aside>
        <main class="main-content">
            <nav class="tab-nav">
                <a class="tab-link active" data-tab="terminal">Terminal</a>
                <a class="tab-link" data-tab="report">Reporte</a>
                <a class="tab-link" data-tab="topology">Topología</a>
                <button id="generate-pdf-btn" type="button" style="display: none;">Generar PDF</button>
            </nav>
            <div class="main-content-body">
                <div id="terminal" class="tab-content active"><pre id="scan-output">Bienvenido a Vigilantor...</pre></div>
                <div id="report" class="tab-content"><div id="report-content">Selecciona un escaneo para generar un reporte.</div></div>
                <div id="topology" class="tab-content">
                    <div id="topology-graph"></div>
                    <div id="graph-tooltip"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const toolsData = {{ tools_data | tojson | safe }};
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof toolsData === 'undefined') {
                document.body.innerHTML = '<h1 style="color: red; font-family: sans-serif; text-align: center; margin-top: 2rem;">Error Crítico: No se pudieron cargar los datos de las herramientas desde el servidor. Asegúrate de que estás ejecutando la última versión del archivo `app.py`.</h1>';
                return;
            }

            const baseUrl = window.location.origin;
            const socket = io.connect(baseUrl);
            
            const elements = {
                toolSelect: document.getElementById('tool-select'),
                toolParams: document.getElementById('tool-params'),
                scanForm: document.getElementById('scan-form'),
                startBtn: document.getElementById('start-scan-btn'),
                stopBtn: document.getElementById('stop-scan-btn'),
                clearBtn: document.getElementById('clear-btn'),
                pdfBtn: document.getElementById('generate-pdf-btn'),
                scanOutput: document.getElementById('scan-output'),
                historyList: document.getElementById('history-list'),
                reportContent: document.getElementById('report-content'),
                topologyGraph: document.getElementById('topology-graph'),
                graphTooltip: document.getElementById('graph-tooltip'),
                tabLinks: document.querySelectorAll('.tab-link'),
                tabContents: document.querySelectorAll('.tab-content')
            };
            
            let currentScanId = null;
            let currentScanData = null;

            function setScanningState(isScanning) {
                elements.startBtn.style.display = isScanning ? 'none' : 'grid';
                elements.stopBtn.style.display = isScanning ? 'block' : 'none';
                elements.toolSelect.disabled = isScanning;
                elements.historyList.style.pointerEvents = isScanning ? 'none' : 'auto';
            }

            function updateButtonVisibility() {
                const hasContent = currentScanId !== null;
                elements.clearBtn.style.display = hasContent ? 'block' : 'none';
                elements.pdfBtn.style.display = hasContent && document.querySelector('.tab-link[data-tab="report"]').classList.contains('active') ? 'block' : 'none';
            }

            function clearViews() {
                elements.scanOutput.textContent = 'Listo para un nuevo escaneo...';
                elements.reportContent.innerHTML = '<p>Selecciona un escaneo para generar un reporte.</p>';
                elements.topologyGraph.innerHTML = '';
                currentScanId = null;
                currentScanData = null;
                setScanningState(false);
                updateButtonVisibility();
            }

            elements.tabLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    elements.tabLinks.forEach(l => l.classList.remove('active'));
                    elements.tabContents.forEach(c => c.classList.remove('active'));
                    link.classList.add('active');
                    document.getElementById(link.dataset.tab).classList.add('active');
                    if (link.dataset.tab === 'topology' && currentScanId) {
                        loadScanDetails(currentScanId, true);
                    }
                    updateButtonVisibility();
                });
            });

            function fetchHistory() {
                fetch(`${baseUrl}/api/scans`)
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(scans => {
                        elements.historyList.innerHTML = '';
                        scans.forEach(scan => {
                            try {
                                const li = document.createElement('li');
                                const targetInfo = JSON.parse(scan.target_info);
                                li.innerHTML = `<strong>${scan.tool}</strong> - ${targetInfo.target} <small>(${scan.status})</small>`;
                                li.dataset.scanId = scan.id;
                                li.addEventListener('click', () => loadScanDetails(scan.id));
                                elements.historyList.appendChild(li);
                            } catch (e) { console.error("Error parsing scan item from history:", scan, e); }
                        });
                    })
                    .catch(error => console.error("Failed to fetch history:", error));
            }

            function updateToolParams() {
                const toolName = elements.toolSelect.value;
                const tool = toolsData[toolName];
                elements.toolParams.innerHTML = '';
                if (tool && tool.user_inputs) {
                    tool.user_inputs.forEach(input => {
                        const label = document.createElement('label');
                        label.htmlFor = `input-${input.name}`;
                        label.textContent = input.name;
                        const inputEl = document.createElement('input');
                        inputEl.id = `input-${input.name}`;
                        inputEl.type = 'text';
                        inputEl.name = input.name;
                        inputEl.placeholder = input.placeholder;
                        inputEl.required = input.required;
                        if (input.name === 'wordlist' && input.placeholder) {
                            inputEl.value = input.placeholder;
                        }
                        elements.toolParams.appendChild(label);
                        elements.toolParams.appendChild(inputEl);
                    });
                }
            }
            
            function loadScanDetails(scanId, forceTopologyRender = false) {
                fetch(`${baseUrl}/api/scan/details/${scanId}`)
                    .then(res => res.ok ? res.json() : Promise.reject(res))
                    .then(data => {
                        if (data.error) {
                            clearViews();
                            elements.scanOutput.textContent = `Error: ${data.error}`;
                            return;
                        }
                        currentScanId = data.id;
                        currentScanData = data;
                        updateButtonVisibility();
                        elements.scanOutput.textContent = data.output || 'No hay salida para este escaneo.';
                        renderDetailedReport(data);
                        if (data.topology) {
                            if (document.querySelector('.tab-link[data-tab="topology"]').classList.contains('active') || forceTopologyRender) {
                                renderTopology(data.topology);
                            }
                        } else {
                            elements.topologyGraph.innerHTML = '<p style="text-align:center; padding: 20px;">No hay datos de topología para este tipo de escaneo.</p>';
                        }
                    })
                    .catch(error => console.error(`Failed to load details for scan ${scanId}:`, error));
            }

            function renderDetailedReport(data) {
                let reportHTML = ``;
                const targetInfo = JSON.parse(data.target_info);

                reportHTML += `<h3>Resumen del Escaneo</h3>`;
                reportHTML += `<p><strong>Herramienta:</strong> ${data.tool}</p>`;
                reportHTML += `<p><strong>Objetivo:</strong> ${targetInfo.target}</p>`;
                reportHTML += `<p><strong>Estado:</strong> ${data.status}</p>`;

                if (data.tool === 'Nmap') {
                    // --- INICIO DE LA LÓGICA CORREGIDA ---
                    const output = data.output || ''; // Asegura que output nunca sea null
                    // --- FIN DE LA LÓGICA CORREGIDA ---
                    const parser = new DOMParser();
                    const xmlStartIndex = output.indexOf('<?xml');
                    
                    if (xmlStartIndex === -1) {
                        reportHTML += `<p style="color: var(--error-color);">Error: No se encontró salida XML válida de Nmap en los resultados.</p>`;
                        elements.reportContent.innerHTML = reportHTML;
                        return;
                    }

                    const xmlString = output.substring(xmlStartIndex);
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        console.error("XML Parse Error:", parseError);
                        reportHTML += `<p style="color: var(--error-color);">Error: El formato del reporte XML de Nmap es inválido.</p>`;
                        elements.reportContent.innerHTML = reportHTML;
                        return;
                    }

                    const hosts = xmlDoc.getElementsByTagName('host');
                    const activeHosts = Array.from(hosts).filter(host => {
                        const status = host.querySelector('status');
                        return status && status.getAttribute('state') === 'up';
                    });
                    
                    reportHTML += `<div class="executive-summary">`;
                    reportHTML += `<p><strong>Resumen Ejecutivo:</strong> Se realizó un escaneo de red en el rango <strong>${targetInfo.target}</strong>, descubriendo <strong>${activeHosts.length}</strong> dispositivos activos. Se recomienda una revisión detallada de los servicios expuestos en cada dispositivo para minimizar la superficie de ataque.</p>`;
                    reportHTML += `</div>`;
                    
                    if (activeHosts.length > 0) {
                        reportHTML += `<h3>Dispositivos Encontrados en la Red</h3>`;
                        activeHosts.forEach((host, index) => {
                            let ipAddress = '', macAddress = '', macVendor = '';
                            const addresses = host.getElementsByTagName('address');
                            for (let addr of addresses) {
                                if (addr.getAttribute('addrtype') === 'ipv4') ipAddress = addr.getAttribute('addr');
                                if (addr.getAttribute('addrtype') === 'mac') {
                                    macAddress = addr.getAttribute('addr');
                                    macVendor = addr.getAttribute('vendor') || '';
                                }
                            }

                            let hostName = ipAddress;
                            const hostnames = host.getElementsByTagName('hostname');
                            if (hostnames.length > 0 && hostnames[0].getAttribute('name')) {
                                hostName = `${hostnames[0].getAttribute('name')} (${ipAddress})`;
                            }
                            
                            reportHTML += `<h4 id="host-header-${index}">${hostName}</h4>`;

                            if (macAddress) {
                                reportHTML += `<p><strong>Dirección MAC:</strong> <code>${macAddress}</code> ${macVendor ? `(${macVendor})` : ''}</p>`;
                            }

                            const osMatch = host.querySelector('osclass');
                            if (osMatch) {
                                reportHTML += `<p><strong>Sistema Operativo:</strong> ${osMatch.getAttribute('osfamily')} (${osMatch.getAttribute('accuracy')}%)</p>`;
                            }

                            reportHTML += `<p><strong>Servicios y Puertos Abiertos:</strong></p>`;
                            const ports = host.querySelector('ports');
                            const portElements = ports ? ports.getElementsByTagName('port') : [];
                            const openPorts = Array.from(portElements).filter(p => p.querySelector('state')?.getAttribute('state') === 'open');

                            if(openPorts.length > 0) {
                                reportHTML += `<table class="nmap-report-table" id="nmap-table-${index}"><thead><tr><th>Puerto</th><th>Protocolo</th><th>Estado</th><th>Servicio</th><th>Versión</th></tr></thead><tbody>`;
                                openPorts.forEach(port => {
                                    const portid = port.getAttribute('portid');
                                    const protocol = port.getAttribute('protocol');
                                    const state = port.querySelector('state')?.getAttribute('state');
                                    const service = port.querySelector('service');
                                    const serviceName = service ? service.getAttribute('name') : 'unknown';
                                    const product = service ? service.getAttribute('product') : '';
                                    const version = service ? service.getAttribute('version') : '';
                                    const fullVersion = [product, version].filter(Boolean).join(' ');
                                    reportHTML += `<tr><td>${portid}</td><td>${protocol.toUpperCase()}</td><td>${state}</td><td>${serviceName}</td><td>${fullVersion}</td></tr>`;
                                });
                                reportHTML += `</tbody></table>`;
                            } else {
                                reportHTML += `<p>No se encontraron puertos abiertos en este dispositivo.</p>`;
                            }

                            const scripts = host.querySelectorAll('script');
                            if (scripts.length > 0) {
                                reportHTML += `<p><strong>Observaciones y Posibles Vulnerabilidades (NSE):</strong></p><ul>`;
                                scripts.forEach(script => {
                                    reportHTML += `<li><code><strong>${script.getAttribute('id')}:</strong> ${script.getAttribute('output').replace(/\n/g, ' ')}</code></li>`;
                                });
                                reportHTML += `</ul>`;
                            }
                        });
                    } else {
                        reportHTML += `<h3>Resultados de Nmap</h3>`;
                        reportHTML += `<p>No se encontraron hosts activos en el rango especificado.</p>`;
                    }

                } else {
                    reportHTML += `<h3>Salida en Bruto</h3><pre><code>${data.output || 'Sin salida.'}</code></pre>`;
                }
                elements.reportContent.innerHTML = reportHTML;
            }
            
            function generatePdf() {
                if (!currentScanData) {
                    alert("No hay datos del escaneo para generar un PDF.");
                    return;
                }

                try {
                    const doc = new window.jspdf.jsPDF();
                    const targetInfo = JSON.parse(currentScanData.target_info);
                    let finalY = 55; // Starting Y position

                    doc.setFontSize(22);
                    doc.text("Reporte de Escaneo - Vigilantor", 14, 22);
                    doc.setFontSize(12);
                    doc.text(`Herramienta: ${currentScanData.tool}`, 14, 35);
                    doc.text(`Objetivo: ${targetInfo.target}`, 14, 41);
                    doc.text(`ID de Escaneo: ${currentScanData.id}`, 14, 47);

                    if (currentScanData.tool === 'Nmap') {
                        const reportElement = elements.reportContent;
                        const summary = reportElement.querySelector('.executive-summary p');
                        if (summary) {
                            doc.setFont('helvetica', 'bold');
                            doc.text("Resumen Ejecutivo", 14, finalY);
                            finalY += 7;
                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(10);
                            const summaryLines = doc.splitTextToSize(summary.innerText, 180);
                            doc.text(summaryLines, 14, finalY);
                            finalY += (summaryLines.length * 5) + 5;
                        }

                        const hostSections = reportElement.querySelectorAll('h4');
                        hostSections.forEach((hostHeader) => {
                            if (finalY > 250) {
                                doc.addPage();
                                finalY = 20;
                            }
                            doc.setFontSize(16);
                            doc.setFont('helvetica', 'bold');
                            doc.text(hostHeader.innerText, 14, finalY);
                            finalY += 8;
                            
                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(10);
                            
                            // --- INICIO DE LA LÓGICA CORREGIDA (SIN :has()) ---
                            let nextEl = hostHeader.nextElementSibling;
                            while (nextEl) {
                                // Si encontramos la tabla de puertos, nos detenemos.
                                if (nextEl.tagName === 'TABLE' || (nextEl.tagName === 'P' && nextEl.innerText.includes('Servicios y Puertos Abiertos'))) {
                                    break;
                                }
                                
                                // Si es un párrafo de detalle, lo añadimos al PDF.
                                if (nextEl.tagName === 'P') {
                                    if (finalY > 275) { doc.addPage(); finalY = 20; }
                                    const detailLines = doc.splitTextToSize(nextEl.innerText, 180);
                                    doc.text(detailLines, 14, finalY);
                                    finalY += (detailLines.length * 5) + 1;
                                }
                                nextEl = nextEl.nextElementSibling;
                            }
                            // --- FIN DE LA LÓGICA CORREGIDA ---
                            finalY += 3;

                            const table = hostHeader.parentElement.querySelector(`#nmap-table-${hostHeader.id.split('-')[2]}`);
                            if (table) {
                                doc.autoTable({
                                    html: table,
                                    startY: finalY,
                                    headStyles: { fillColor: [35, 134, 54] },
                                });
                                finalY = doc.lastAutoTable.finalY + 10;
                            }

                            const nseList = hostHeader.parentElement.querySelector('ul');
                            if (nseList) {
                                if (finalY > 260) { doc.addPage(); finalY = 20; }
                                doc.setFontSize(12);
                                doc.setFont('helvetica', 'bold');
                                doc.text("Observaciones (NSE):", 14, finalY);
                                finalY += 7;
                                doc.setFontSize(9);
                                doc.setFont('helvetica', 'normal');
                                const items = Array.from(nseList.querySelectorAll('li'));
                                items.forEach(item => {
                                    if (finalY > 280) { doc.addPage(); finalY = 20; }
                                    const itemLines = doc.splitTextToSize(`- ${item.innerText}`, 175);
                                    doc.text(itemLines, 16, finalY);
                                    finalY += (itemLines.length * 4) + 2;
                                });
                            }
                            finalY += 10;
                        });

                    } else {
                        const reportText = elements.reportContent.innerText;
                        doc.setFontSize(10);
                        const textLines = doc.splitTextToSize(reportText, 180);
                        doc.text(textLines, 14, finalY);
                    }

                    doc.save(`Vigilantor-Reporte-${currentScanData.id.substring(0,8)}.pdf`);

                } catch (error) {
                    console.error("Error al generar el PDF:", error);
                    alert("Ocurrió un error al intentar generar el PDF. Revisa la consola del navegador para más detalles (F12).");
                }
            }

            function renderTopology(topologyData) {
                if (!topologyData || !topologyData.nodes || !topologyData.nodes.length === 0) {
                    elements.topologyGraph.innerHTML = '<p style="text-align:center; padding: 20px;">No se encontraron hosts para visualizar.</p>';
                    return;
                }

                topologyData.nodes.forEach(node => {
                    node.shape = 'icon';
                    if (node.group === 'target') {
                        node.icon = { face: 'FontAwesome', code: '\uf140', size: 50, color: '#f85149' }; // fa-bullseye
                    }
                    if (node.group === 'host') {
                        node.icon = { face: 'FontAwesome', code: '\uf233', size: 50, color: '#3ddc55' }; // fa-server
                    }
                    if (node.group === 'port') {
                        node.icon = { face: 'FontAwesome', code: '\uf0ac', size: 50, color: '#0095ff' }; // fa-globe
                    }
                });

                const container = elements.topologyGraph;
                const data = { nodes: new vis.DataSet(topologyData.nodes), edges: new vis.DataSet(topologyData.edges) };
                const options = {
                    nodes: {
                        size: 24,
                        font: { color: getComputedStyle(document.documentElement).getPropertyValue('--fg-color').trim(), size: 12 },
                        shapeProperties: { useBorderWithImage: true },
                        borderWidth: 2,
                        borderWidthSelected: 4
                    },
                    edges: {
                        width: 1,
                        color: { inherit: 'from', opacity: 0.7 },
                        smooth: { type: 'continuous' }
                    },
                    physics: {
                        barnesHut: {
                            gravitationalConstant: -3000,
                            centralGravity: 0.1,
                            springLength: 150,
                        },
                        stabilization: { iterations: 2500 }
                    },
                    interaction: {
                        hover: true,
                        tooltipDelay: 200
                    }
                };
                
                const network = new vis.Network(container, data, options);

                network.on("hoverNode", function (params) {
                    const nodeId = params.node;
                    const node = data.nodes.get(nodeId);
                    elements.graphTooltip.innerHTML = `<strong>${node.group.toUpperCase()}:</strong><br>${node.label}`;
                    elements.graphTooltip.style.display = 'block';
                });

                network.on("mousemove", function (params) {
                    elements.graphTooltip.style.left = params.event.pageX + 15 + 'px';
                    elements.graphTooltip.style.top = params.event.pageY - 20 + 'px';
                });

                network.on("blurNode", function (params) {
                    elements.graphTooltip.style.display = 'none';
                });
            }

            // --- SOCKET LISTENERS ---
            socket.on('scan_started', data => {
                currentScanId = data.scan_id;
                elements.scanOutput.textContent = `Iniciando escaneo con ${data.tool} sobre ${data.target}...\nID: ${data.scan_id}\n\n`;
                elements.reportContent.innerHTML = '<p>Generando reporte...</p>';
                elements.topologyGraph.innerHTML = '';
                setScanningState(true);
                updateButtonVisibility();
            });

            socket.on('scan_update', data => {
                if (data.scan_id === currentScanId) {
                    elements.scanOutput.textContent += data.output;
                    elements.scanOutput.scrollTop = elements.scanOutput.scrollHeight;
                }
            });

            socket.on('scan_finished', data => {
                if (data.scan_id === currentScanId) {
                    setScanningState(false);
                }
                fetchHistory();
                loadScanDetails(data.scan_id);
            });
            
            socket.on('scan_stopped', data => {
                if (data.scan_id === currentScanId) {
                    elements.scanOutput.textContent += `\n\n--- ${data.message} ---\n`;
                    setScanningState(false);
                    fetchHistory();
                }
            });

            socket.on('scan_error', data => {
                 if (data.scan_id === currentScanId) {
                    elements.scanOutput.textContent += `\n\n--- ERROR: ${data.error} ---\n`;
                    setScanningState(false);
                    fetchHistory();
                }
            });

            // --- EVENT HANDLERS ---
            elements.toolSelect.addEventListener('change', updateToolParams);
            elements.pdfBtn.addEventListener('click', generatePdf);
            
            elements.scanForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const selectedTool = elements.toolSelect.value;
                const params = {};
                elements.toolParams.querySelectorAll('input').forEach(input => { params[input.name] = input.value; });
                socket.emit('start_scan', { tool: selectedTool, params: params });
            });

            elements.stopBtn.addEventListener('click', () => {
                if (currentScanId) {
                    socket.emit('stop_scan', { 'scan_id': currentScanId });
                }
            });

            elements.clearBtn.addEventListener('click', () => {
                clearViews();
            });

            // --- INITIALIZATION ---
            function initializeApp() {
                clearViews();
                elements.toolSelect.innerHTML = '';
                if (toolsData && Object.keys(toolsData).length > 0) {
                    Object.keys(toolsData).forEach(name => elements.toolSelect.add(new Option(name, name)));
                    updateToolParams();
                } else {
                    elements.toolParams.innerHTML = '<p style="color: var(--error-color);">No se pudieron cargar las herramientas.</p>';
                }
                fetchHistory();
            }

            initializeApp();
        });
    </script>
</body>
</html>